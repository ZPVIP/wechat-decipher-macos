# Overview of the Backup Process

In this document, we briefly describe the process of a backup from WeChat's iOS client to its macOS client. Only key steps are covered.

We first note that WeChat makes extensive use of [Protocol Buffers](https://developers.google.com/protocol-buffers), and the mobile team made significant changes to the code generated by `protoc`. Fortunately, the article [iOS微信安装包瘦身](https://cloud.tencent.com/developer/article/1030792) provides a decent overview of protobuf's integration into WeChat's iOS client. Based on the information, we created a helper function `show_fields` in `init.js` which takes an instance of `WXPBGeneratedMessage` (or a subclass thereof) and restore its original message definition.

The backup process is as follows. Steps 1 through 7 happen on the iOS device, whereas steps 8 and 9 are performed by the macOS client.

1. Both clients get a 256-bit "encryptkey" from server with `-[WXGBackupMgr onGetConnectInfo:]`.
    + This is *NOT* the same key as used by `macos/dbcracker.d`.
    + The ASCII representation of the key consists of 32 hexadecimal digits, so there are merely 128 bits of entropy. However, we consider it a 256-bit key anyway since it still takes 256 bits of space to store.
    + Run `frida-trace -U -n WeChat -m "-[ChatMigrationGetConnectInfo getConnectInfo:]" -m "-[ProtobufCGIWrap setM_pbRequest:]" -m "-[ChatMigrationGetConnectInfo MessageReturn:Event:]" --init-session=init.js` to learn more about the process. Here we dissect the request body in `-[ProtobufCGIWrap setM_pbRequest:]` and the response body in `-[ChatMigrationGetConnectInfo MessageReturn:Event:]`.
    + The iOS client's communication with WeChat's server is done via the [mars](https://github.com/Tencent/mars) subsystem, whose I/O interface seems to be `-[EventService req2Buf:Out:Host:]` and `-[EventService buf2Resp:In:Err:Flags:]`.
2. On the iOS device, the relevant chat history is read from the [wcdb](https://github.com/Tencent/wcdb) subsystem into `CMessageWrap` objects with `-[WXGBackupMMDB getMsgUseBatchQuery:fromRowID:fromCreateTime:endAtTime:timeAsend:]`.
3. The `CMessageWrap` objects are eventually transformed into several `BakChatMsgList` object. There appears to be one `BakChatMsgList` per contact.
4. The `BakChatMsgList` objects are serialized into protobuf (with `-[WXPBGeneratedMessage serializedData]`), encrypted in AES-128-ECB (with `-[CAESCrypt initECBEncryptWithKey:]` and `-[CAESCrypt encryptECBWithData:Final:]`).
    + The encrypt key is the first 128 bits of "encryptkey".
    + `BakChatMsgList` is a subclass of `WXPBGeneratedMessage`, which means its instances can be serialized to protobuf. Run `frida-trace -U -n WeChat -m "-[WXGBackupDataMgr getBackupDataPushFromBakChatMsgList:withDataID:]" --init-session=init.js` to learn more about the process. We reconstructed `pcbakchat/proto/BakChatMsgList.proto` based on its output.
5. Media data are also encrypted in AES-128-ECB (with `-[WXGBackupDataMgr purgeMediaArray:]`).
6. The encrypted protobufs are then packed with metadata like `dataID` (presumably an identifier of the chat history) into a "datapush", which is another layer of protobuf (with `-[WXGBackupDataMgr getBackupDataPushFromBakChatMsgList:withDataID:]`)
7. The datapushes are encrypted in RC4 and sent to the macOS client over Wi-Fi.
    + The encrypt key is the 256-bit "encryptkey" in all its entirety.
8. On the macOS client, the datapushes are decrypted in RC4 (with `CCCryptor`) and deserialized.
    + It would also re-encrypt the datapushes after the decryption, presumably with some modification to the content. We have not investigated this behavior yet.
9. Finally, `dataID` is extracted and used to dispatch the encrypted "inner" protobuf to one of `BAK_X_TEXT`.

**TL;DR:** the chat history is packed, encrypted in AES-128-ECB, packed with some metadata, encrypted with RC4, sent over Wi-Fi, decrypted (RC4), unpacked, and stored to the disk.